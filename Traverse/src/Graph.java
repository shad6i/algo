/**
 * Представление неориентированного ненагруженного графа списками смежности.
 * В классе также определена процедура обхода графа "в глубину".
 */
public class Graph {
    /**
     * Элемент списка смежности, представляющий дугу.
     */
    private static class Arc {
        int to;     // номер вершины, в которую ведет дуга
        Arc next;   // следующий элемент в списке смежности

        //--------- Конструкторы -------------
        Arc(int to, Arc next) { this.to = to; this.next = next; }
        Arc(int to) { this(to, null); }
    }

    /**
     * Массив списков смежности, представляющий собственно граф.
     */
    private final Arc[] graph;

    /**
     * Размер графа - число вершин.
     */
    private final int n;

    /**
     * Конструктор пустого графа (все вершины - изолированные).
     * @param n Число вершин в графе.
     */
    public Graph(int n) {
        this.n = n;
        graph = new Arc[n];
    }

    /**
     * Функция, добавляющая ребро в граф.
     * Несмотря на "публичный" статус, функция не проверяет правильность задания аргументов;
     * предполагается, что функция вызывается "квалифицированным" пользователем, который правильно задает аргументы.
     * Добавляемое ребро представлено двумя противоположно направленными дугами.
     * @param from  Номер одного из концов ребра.
     * @param to    Номер другого конца ребра.
     */
    public void addArc(int from, int to) {
        graph[from] = new Arc(to, graph[from]);
        graph[to] = new Arc(from, graph[to]);
    }

    /**
     * Обход компоненты графа (в случае связного графа - всего графа), начинающийся в вершине с номером 0.
     * @param action    Определяет действия, выполняемые при обходе вершин и дуг графа.
     */
    public void traverse(Action action) {
        // Массив, в котором помечаются пройденные вершины:
        boolean[] passed = new boolean[n];
        // Рекурсивная функция обходит еще не обойденную часть графа, достижимую из вершины с заданным номером.
        traverse(0, passed, action);
    }

    /**
     * Обход еще не пройденной части графа, достижтмой из вершины с указанным номером.
     * @param u         Номер начальной вершины
     * @param passed    Массив для отметок о пройденный вершинах
     * @param action    Определяет действия, производимые с вершинами и дугами при обходе.
     */
    private void traverse(int u, boolean[] passed, Action action) {
        // Вершина проходится и помечается как пройденная.
        passed[u] = true;
        action.processVertex(u);
        // Перебираем и проходим дуги, ведущие из данной вершины.
        for (Arc arc = graph[u]; arc!= null; arc = arc.next) {
            int v = arc.to;
            action.processArc(u, v);
            // Если дуга ведет в еще не пройденную вершину, то в соответствии
            // с логикой обхода в глубину продолжаем обход из этой новой вершины.
            if (!passed[v]) traverse(v, passed, action);
        }
    }
}
