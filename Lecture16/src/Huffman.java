import java.util.Arrays;

/**
 * Реализация алгоритма построения оптимальных кодов символов по Хаффмену.
 * Данная реализация не слишком эффективна для действительно больших алфавитов,
 * поскольку реализована на массивах, элементы в которых приходится передвигать.
 */
public class Huffman {
	// Массив вероятностей появления символов в сообщении
	final double[] m_probs;
	// Массив строящихся кодов символов
	final String[] m_codes;
	
	/**
	 * Основная статическая функция построения кодов по алгоритму Хаффмена.
	 * @param p Массив вероятностей появления символов в сообщении,
	 *          упорядоченный по убыванию.
	 * @return Массив соответствующих кодов.
	 */
	public static String[] huffman(double[] p) {
		// Этот объект сохраняет данные.
		Huffman huffman = new Huffman(p);
		
		// Вызов основной рекурсивной функции построения кодов.
		huffman.huffman(p.length);
		
		// Выдача результата
		return huffman.m_codes;
	}
	
	/**
	 * Коструктор сохраняет исходный (упорядоченный) массив вероятностей
	 * и строит массив кодов (пока пустой).
	 * @param p Массив вероятностей появления символов в сообщении.
	 */
	private Huffman(double[] p) {
		m_probs = p;
		int n = p.length;
		
		// Построение начального массива (пустых) кодов.
		m_codes = new String[n];
		//for (int i = 0; i < n; ++i) m_codes[i] = "";
	}
	
	/**
	 * Основная рекурсивная функция.
	 * @param n Количество оставшихся "псевдосимволов".
	 */
	private void huffman(int n) {
		if (n == 2) {
			// Остались всего два псевдосимвола - назначаем им коды "0" и "1".
			m_codes[0] = "0";
			m_codes[1] = "1";
		} else {
			// Объединяем символы с наименьшими вероятностями в один псевдосимвол
			// и ставим соответствующую вероятность на свое место в массиве.
			int j = up(n);
			// рекурсивный вызов
			huffman(n-1);
			// Разделение объединенного псевдосимвола и назначение кодов.
			down(n, j);
		}
	}
	
	/**
	 * Объединение двух псевдосимволов в один с приписыванием ему суммы
	 * вероятностей исходных псевдосимволов.
	 * @param n Число псевдосимволов
	 * @return Место вставки нового псевдосимвола
	 */
	private int up(int n) {
		double q = m_probs[n-1] + m_probs[n-2];
		int i = n - 2;
		while (i > 0 && m_probs[i-1] <= q) {
			m_probs[i] = m_probs[i-1];
			i--;
		}
		m_probs[i] = q;
		return i;
	}
	
	/**
	 * Разделение псевдосимвола с назначением кодов двум половинам.
	 * @param n Число псевдосимволов после разделения
	 * @param j Индекс псевдосимвола, подлежащего делению.
	 */
	private void down(int n, int j) {
		String code = m_codes[j];
		for (int i = j; i < n-2; i++) m_codes[i] = m_codes[i+1];
		m_codes[n-2] = code + "0";
		m_codes[n-1] = code + "1";
	}
	
	/**
	 * Проверка на простом примере.
	 * @param args
	 */
	public static void main(String[] args) {
		double[] p = {0.20, 0.20, 0.19, 0.12, 0.11, 0.09, 0.09};
		System.out.println(Arrays.toString(Huffman.huffman(p)));
	}
}
